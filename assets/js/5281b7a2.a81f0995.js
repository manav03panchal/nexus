"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[2443],{936(e,n,s){s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"architecture","title":"Architecture","description":"Deep dive into Nexus internals: how it parses configurations, resolves dependencies, manages SSH connections, and executes tasks.","source":"@site/docs/architecture.md","sourceDirName":".","slug":"/architecture","permalink":"/nexus/architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/manav03panchal/nexus/tree/main/website/docs/architecture.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"docsSidebar","previous":{"title":"Examples","permalink":"/nexus/examples"},"next":{"title":"SSH Configuration","permalink":"/nexus/ssh"}}');var o=s(4848),r=s(8453);const i={sidebar_position:6},a="Architecture",l={},d=[{value:"Overview",id:"overview",level:2},{value:"Module Overview",id:"module-overview",level:2},{value:"Core Modules",id:"core-modules",level:3},{value:"Type System",id:"type-system",level:2},{value:"Host",id:"host",level:3},{value:"Command",id:"command",level:3},{value:"Task",id:"task",level:3},{value:"Config",id:"config",level:3},{value:"DSL Parser",id:"dsl-parser",level:2},{value:"How It Works",id:"how-it-works",level:3},{value:"DSL Implementation",id:"dsl-implementation",level:3},{value:"Host String Parsing",id:"host-string-parsing",level:3},{value:"DAG (Directed Acyclic Graph)",id:"dag-directed-acyclic-graph",level:2},{value:"Graph Construction",id:"graph-construction",level:3},{value:"Execution Phases",id:"execution-phases",level:3},{value:"Example",id:"example",level:3},{value:"Pipeline Execution",id:"pipeline-execution",level:2},{value:"Execution Flow",id:"execution-flow",level:3},{value:"Code Flow",id:"code-flow",level:3},{value:"Task Runner",id:"task-runner",level:2},{value:"Execution Strategies",id:"execution-strategies",level:3},{value:"Command Execution with Retry",id:"command-execution-with-retry",level:3},{value:"SSH Layer",id:"ssh-layer",level:2},{value:"Connection Management",id:"connection-management",level:3},{value:"Connection Pooling",id:"connection-pooling",level:3},{value:"Pool Architecture",id:"pool-architecture",level:3},{value:"Authentication Resolution",id:"authentication-resolution",level:3},{value:"Local Execution",id:"local-execution",level:2},{value:"Telemetry",id:"telemetry",level:2},{value:"Attaching Handlers",id:"attaching-handlers",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Error Types",id:"error-types",level:3},{value:"Error Propagation",id:"error-propagation",level:3},{value:"Performance Characteristics",id:"performance-characteristics",level:2},{value:"Benchmarks",id:"benchmarks",level:3},{value:"Connection Pooling Impact",id:"connection-pooling-impact",level:3},{value:"Memory Usage",id:"memory-usage",level:3},{value:"Extension Points",id:"extension-points",level:2},{value:"Custom Authentication",id:"custom-authentication",level:3},{value:"Custom Output Handlers",id:"custom-output-handlers",level:3},{value:"See Also",id:"see-also",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"architecture",children:"Architecture"})}),"\n",(0,o.jsx)(n.p,{children:"Deep dive into Nexus internals: how it parses configurations, resolves dependencies, manages SSH connections, and executes tasks."}),"\n",(0,o.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(n.p,{children:"Nexus is built with a modular architecture following Elixir/OTP best practices:"}),"\n",(0,o.jsx)(n.mermaid,{value:'flowchart TB\n    subgraph CLI["CLI Layer"]\n        cli["Nexus.CLI"]\n        cli_cmds["Run | List | Validate | Init | Preflight"]\n        cli --\x3e cli_cmds\n    end\n\n    subgraph Config["Configuration Layer"]\n        parser["Nexus.DSL.Parser"]\n        validator["Nexus.DSL.Validator"]\n        types["Nexus.Types.*"]\n        parser --\x3e validator\n        validator --\x3e types\n    end\n\n    subgraph Exec["Execution Layer"]\n        dag["Nexus.DAG"]\n        pipeline["Nexus.Executor.Pipeline"]\n        runner["TaskRunner"]\n        dag --\x3e pipeline --\x3e runner\n    end\n\n    subgraph Local["Local Executor"]\n        local["Nexus.Executor.Local"]\n    end\n\n    subgraph SSH["SSH Layer"]\n        conn["Nexus.SSH.Connection"]\n        pool["Nexus.SSH.Pool"]\n        auth["Nexus.SSH.Auth"]\n        sshconfig["Nexus.SSH.ConfigParser"]\n    end\n\n    CLI --\x3e Config --\x3e Exec\n    Exec --\x3e Local\n    Exec --\x3e SSH'}),"\n",(0,o.jsx)(n.h2,{id:"module-overview",children:"Module Overview"}),"\n",(0,o.jsx)(n.h3,{id:"core-modules",children:"Core Modules"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Module"}),(0,o.jsx)(n.th,{children:"Purpose"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Nexus.CLI"})}),(0,o.jsx)(n.td,{children:"Entry point, command routing, argument parsing"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Nexus.DSL.Parser"})}),(0,o.jsxs)(n.td,{children:["Parses ",(0,o.jsx)(n.code,{children:"nexus.exs"})," files into structured config"]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Nexus.DSL.Validator"})}),(0,o.jsx)(n.td,{children:"Validates configuration for errors"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Nexus.Types"})}),(0,o.jsx)(n.td,{children:"Type definitions (Host, Task, Command, Config)"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Nexus.DAG"})}),(0,o.jsx)(n.td,{children:"Dependency graph construction and resolution"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Nexus.Executor.Pipeline"})}),(0,o.jsx)(n.td,{children:"Orchestrates task execution"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Nexus.Executor.TaskRunner"})}),(0,o.jsx)(n.td,{children:"Executes individual tasks"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Nexus.Executor.Local"})}),(0,o.jsx)(n.td,{children:"Local command execution"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Nexus.SSH.Connection"})}),(0,o.jsx)(n.td,{children:"SSH connection management"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Nexus.SSH.Pool"})}),(0,o.jsx)(n.td,{children:"Connection pooling with NimblePool"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Nexus.SSH.Auth"})}),(0,o.jsx)(n.td,{children:"Authentication resolution"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Nexus.SSH.ConfigParser"})}),(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"~/.ssh/config"})," parsing"]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Nexus.Preflight.Checker"})}),(0,o.jsx)(n.td,{children:"Pre-flight validation checks"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Nexus.Output.Formatter"})}),(0,o.jsx)(n.td,{children:"Output formatting"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Nexus.Telemetry"})}),(0,o.jsx)(n.td,{children:"Telemetry events"})]})]})]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"type-system",children:"Type System"}),"\n",(0,o.jsxs)(n.p,{children:["Nexus uses structured types defined in ",(0,o.jsx)(n.code,{children:"Nexus.Types"}),":"]}),"\n",(0,o.jsx)(n.h3,{id:"host",children:"Host"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-elixir",children:'defmodule Nexus.Types.Host do\n  @type t :: %__MODULE__{\n    name: atom(),           # :web1\n    hostname: String.t(),   # "192.168.1.10"\n    user: String.t() | nil, # "deploy"\n    port: pos_integer()     # 22\n  }\nend\n'})}),"\n",(0,o.jsx)(n.h3,{id:"command",children:"Command"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-elixir",children:'defmodule Nexus.Types.Command do\n  @type t :: %__MODULE__{\n    cmd: String.t(),              # "echo hello"\n    sudo: boolean(),              # false\n    user: String.t() | nil,       # nil\n    timeout: pos_integer(),       # 60_000\n    retries: non_neg_integer(),   # 0\n    retry_delay: pos_integer()    # 1_000\n  }\nend\n'})}),"\n",(0,o.jsx)(n.h3,{id:"task",children:"Task"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-elixir",children:"defmodule Nexus.Types.Task do\n  @type t :: %__MODULE__{\n    name: atom(),                      # :deploy\n    deps: [atom()],                    # [:build, :test]\n    on: atom(),                        # :webservers | :local\n    commands: [Command.t()],           # [%Command{...}, ...]\n    timeout: pos_integer(),            # 300_000\n    strategy: :parallel | :serial      # :parallel\n  }\nend\n"})}),"\n",(0,o.jsx)(n.h3,{id:"config",children:"Config"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-elixir",children:"defmodule Nexus.Types.Config do\n  @type t :: %__MODULE__{\n    default_user: String.t() | nil,\n    default_port: pos_integer(),\n    connect_timeout: pos_integer(),\n    command_timeout: pos_integer(),\n    max_connections: pos_integer(),\n    continue_on_error: boolean(),\n    hosts: %{atom() => Host.t()},\n    groups: %{atom() => HostGroup.t()},\n    tasks: %{atom() => Task.t()}\n  }\nend\n"})}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"dsl-parser",children:"DSL Parser"}),"\n",(0,o.jsxs)(n.p,{children:["The DSL parser (",(0,o.jsx)(n.code,{children:"Nexus.DSL.Parser"}),") transforms ",(0,o.jsx)(n.code,{children:"nexus.exs"})," files into ",(0,o.jsx)(n.code,{children:"Config"})," structs."]}),"\n",(0,o.jsx)(n.h3,{id:"how-it-works",children:"How It Works"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"File Reading"}),": Read the ",(0,o.jsx)(n.code,{children:"nexus.exs"})," file content"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"DSL Wrapping"}),": Wrap content in a module that provides DSL macros"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Evaluation"}),": Use ",(0,o.jsx)(n.code,{children:"Code.eval_string/3"})," to evaluate the wrapped code"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"State Tracking"}),": Use process dictionary to accumulate config during evaluation"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Return"}),": Return the final ",(0,o.jsx)(n.code,{children:"Config"})," struct"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"dsl-implementation",children:"DSL Implementation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-elixir",children:"# The DSL module provides macros like:\ndefmodule Nexus.DSL.Parser.DSL do\n  defmacro host(name, connection_string) do\n    quote do\n      Nexus.DSL.Parser.DSL.do_host(unquote(name), unquote(connection_string))\n    end\n  end\n  \n  def do_host(name, connection_string) do\n    config = Process.get(:nexus_config)\n    {:ok, host} = Host.parse(name, connection_string)\n    Process.put(:nexus_config, Config.add_host(config, host))\n  end\n  \n  defmacro task(name, opts \\\\ [], do: block) do\n    quote do\n      Nexus.DSL.Parser.DSL.do_task(unquote(name), unquote(opts), fn ->\n        unquote(block)\n      end)\n    end\n  end\n  \n  # ... similar for config, group, run\nend\n"})}),"\n",(0,o.jsx)(n.h3,{id:"host-string-parsing",children:"Host String Parsing"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"Host.parse/2"})," function handles various connection string formats:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-elixir",children:'def parse(name, host_string) do\n  cond do\n    # user@hostname:port\n    String.match?(host_string, ~r/^[^@]+@[^:]+:\\d+$/) ->\n      [user_host, port] = String.split(host_string, ":", parts: 2)\n      [user, hostname] = String.split(user_host, "@", parts: 2)\n      {:ok, %Host{name: name, hostname: hostname, user: user, port: String.to_integer(port)}}\n    \n    # user@hostname\n    String.match?(host_string, ~r/^[^@]+@[^:]+$/) ->\n      [user, hostname] = String.split(host_string, "@", parts: 2)\n      {:ok, %Host{name: name, hostname: hostname, user: user, port: 22}}\n    \n    # hostname:port\n    String.match?(host_string, ~r/^[^@:]+:\\d+$/) ->\n      [hostname, port] = String.split(host_string, ":", parts: 2)\n      {:ok, %Host{name: name, hostname: hostname, user: nil, port: String.to_integer(port)}}\n    \n    # hostname only\n    String.match?(host_string, ~r/^[^@:]+$/) ->\n      {:ok, %Host{name: name, hostname: host_string, user: nil, port: 22}}\n  end\nend\n'})}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"dag-directed-acyclic-graph",children:"DAG (Directed Acyclic Graph)"}),"\n",(0,o.jsxs)(n.p,{children:["The DAG module (",(0,o.jsx)(n.code,{children:"Nexus.DAG"}),") handles dependency resolution using the ",(0,o.jsx)(n.code,{children:"libgraph"})," library."]}),"\n",(0,o.jsx)(n.h3,{id:"graph-construction",children:"Graph Construction"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-elixir",children:"def build(%Config{tasks: tasks}) do\n  graph = tasks\n    |> Map.values()\n    |> Enum.reduce(Graph.new(), fn task, g ->\n      g = Graph.add_vertex(g, task.name)\n      \n      # Add edges from dependencies to this task\n      Enum.reduce(task.deps, g, fn dep, acc ->\n        Graph.add_edge(acc, dep, task.name)\n      end)\n    end)\n  \n  if Graph.is_acyclic?(graph) do\n    {:ok, graph}\n  else\n    cycle = find_cycle_path(graph)\n    {:error, {:cycle, cycle}}\n  end\nend\n"})}),"\n",(0,o.jsx)(n.h3,{id:"execution-phases",children:"Execution Phases"}),"\n",(0,o.jsx)(n.p,{children:"Tasks are grouped into phases where:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Tasks in the same phase have no dependencies on each other"}),"\n",(0,o.jsx)(n.li,{children:"Phases are executed sequentially"}),"\n",(0,o.jsx)(n.li,{children:"Tasks within a phase can run in parallel"}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-elixir",children:"def execution_phases(graph) do\n  # Calculate depth (longest path from root) for each vertex\n  depths = calculate_depths(graph)\n  \n  # Group vertices by depth\n  graph\n  |> Graph.vertices()\n  |> Enum.group_by(fn v -> Map.get(depths, v, 0) end)\n  |> Enum.sort_by(fn {depth, _} -> depth end)\n  |> Enum.map(fn {_, tasks} -> Enum.sort(tasks) end)\nend\n"})}),"\n",(0,o.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,o.jsx)(n.p,{children:"Given tasks:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"build (no deps)\nlint (no deps)\ntest (deps: build)\ndeploy (deps: test, lint)\n"})}),"\n",(0,o.jsx)(n.p,{children:"Produces:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Phase 1: [build, lint]    # Can run in parallel\nPhase 2: [test]           # Depends on build\nPhase 3: [deploy]         # Depends on test and lint\n"})}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"pipeline-execution",children:"Pipeline Execution"}),"\n",(0,o.jsxs)(n.p,{children:["The pipeline executor (",(0,o.jsx)(n.code,{children:"Nexus.Executor.Pipeline"}),") orchestrates task execution."]}),"\n",(0,o.jsx)(n.h3,{id:"execution-flow",children:"Execution Flow"}),"\n",(0,o.jsx)(n.mermaid,{value:'flowchart TD\n    subgraph Step1["1. Build Execution Plan"]\n        resolve["Resolve target tasks & dependencies"]\n        dag["Build DAG & compute phases"]\n        resolve --\x3e dag\n    end\n\n    subgraph Step2["2. Execute Phases Sequentially"]\n        phase["For each phase"]\n        parallel["Run tasks in parallel<br/>(up to parallel_limit)"]\n        task["For each task"]\n        hosts["Resolve hosts"]\n        runner["Use TaskRunner to execute"]\n        phase --\x3e parallel --\x3e task --\x3e hosts --\x3e runner\n    end\n\n    subgraph Step3["3. Aggregate Results"]\n        track["Track success/failure counts"]\n        handle["Handle continue_on_error"]\n        track --\x3e handle\n    end\n\n    Step1 --\x3e Step2 --\x3e Step3'}),"\n",(0,o.jsx)(n.h3,{id:"code-flow",children:"Code Flow"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-elixir",children:"def run(%Config{} = config, target_tasks, opts) do\n  with {:ok, plan} <- build_execution_plan(config, target_tasks) do\n    execute_plan(config, plan, opts)\n  end\nend\n\ndefp execute_plan(config, plan, opts) do\n  Enum.reduce_while(plan.phases, initial_state, fn phase, state ->\n    {:ok, results} = execute_phase(config, phase, plan.task_details, opts)\n    \n    if has_failures?(results) and not opts[:continue_on_error] do\n      {:halt, state_with_abort}\n    else\n      {:cont, updated_state}\n    end\n  end)\nend\n\ndefp execute_phase(config, phase, task_details, opts) do\n  phase\n  |> Task.async_stream(fn task_name ->\n    task = Map.fetch!(task_details, task_name)\n    hosts = resolve_task_hosts(config, task)\n    TaskRunner.run(task, hosts, opts)\n  end, max_concurrency: opts[:parallel_limit])\n  |> collect_results()\nend\n"})}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"task-runner",children:"Task Runner"}),"\n",(0,o.jsxs)(n.p,{children:["The task runner (",(0,o.jsx)(n.code,{children:"Nexus.Executor.TaskRunner"}),") executes a single task across hosts."]}),"\n",(0,o.jsx)(n.h3,{id:"execution-strategies",children:"Execution Strategies"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Parallel"})," (default):"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-elixir",children:"defp run_parallel(task, hosts, opts) do\n  hosts\n  |> Task.async_stream(fn host -> \n    run_on_host(task, host, opts)\n  end, timeout: task.timeout)\n  |> collect_results()\nend\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Serial"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-elixir",children:"defp run_serial(task, hosts, opts) do\n  Enum.reduce_while(hosts, [], fn host, acc ->\n    result = run_on_host(task, host, opts)\n    \n    if result.status == :error and not opts[:continue_on_error] do\n      {:halt, [result | acc]}\n    else\n      {:cont, [result | acc]}\n    end\n  end)\nend\n"})}),"\n",(0,o.jsx)(n.h3,{id:"command-execution-with-retry",children:"Command Execution with Retry"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-elixir",children:"defp execute_with_retry(command, executor, attempt) do\n  result = executor.(command)\n  \n  case result do\n    {:ok, output, 0} ->\n      success_result(command, output, attempt)\n    \n    {:ok, output, exit_code} when attempt <= command.retries ->\n      Process.sleep(calculate_retry_delay(command.retry_delay, attempt))\n      execute_with_retry(command, executor, attempt + 1)\n    \n    {:ok, output, exit_code} ->\n      failure_result(command, output, exit_code, attempt)\n    \n    {:error, reason} when attempt <= command.retries ->\n      Process.sleep(calculate_retry_delay(command.retry_delay, attempt))\n      execute_with_retry(command, executor, attempt + 1)\n    \n    {:error, reason} ->\n      error_result(command, reason, attempt)\n  end\nend\n\n# Exponential backoff with jitter\ndefp calculate_retry_delay(base_delay, attempt) do\n  multiplier = :math.pow(2, attempt - 1)\n  delay = round(multiplier * base_delay)\n  jitter = :rand.uniform(round(delay * 0.2))\n  delay + jitter\nend\n"})}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"ssh-layer",children:"SSH Layer"}),"\n",(0,o.jsx)(n.h3,{id:"connection-management",children:"Connection Management"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"Nexus.SSH.Connection"})," wraps SSHKit for SSH operations:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-elixir",children:"def connect(%Host{} = host, opts) do\n  ssh_opts = build_ssh_opts(opts)\n  \n  case SSH.connect(host.hostname, ssh_opts) do\n    {:ok, conn} -> {:ok, conn}\n    {:error, :timeout} -> {:error, {:connection_timeout, host.hostname}}\n    {:error, :econnrefused} -> {:error, {:connection_refused, host.hostname}}\n    {:error, reason} -> {:error, {:connection_failed, host.hostname, reason}}\n  end\nend\n\ndef exec(conn, command, opts) do\n  timeout = Keyword.get(opts, :timeout, 60_000)\n  \n  case SSH.run(conn, command, timeout: timeout) do\n    {:ok, output_list, exit_code} ->\n      {:ok, format_output(output_list), exit_code}\n    {:error, :timeout} ->\n      {:error, {:command_timeout, command}}\n    {:error, reason} ->\n      {:error, {:exec_failed, command, reason}}\n  end\nend\n"})}),"\n",(0,o.jsx)(n.h3,{id:"connection-pooling",children:"Connection Pooling"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"Nexus.SSH.Pool"})," uses NimblePool for efficient connection reuse:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-elixir",children:"defmodule Nexus.SSH.Pool do\n  @behaviour NimblePool\n  \n  def checkout(host, fun, opts) do\n    pool = get_or_create_pool(host, opts)\n    \n    NimblePool.checkout!(pool, :checkout, fn _from, conn ->\n      result = fun.(conn)\n      \n      if connection_valid?(conn) do\n        {result, :ok}\n      else\n        {result, :remove}\n      end\n    end)\n  end\n  \n  @impl NimblePool\n  def handle_checkout(:checkout, _from, {host, opts, nil}, pool_state) do\n    # Lazy connection creation\n    case Connection.connect(host, opts) do\n      {:ok, conn} -> {:ok, conn, {host, opts, conn}, pool_state}\n      {:error, reason} -> {:remove, reason, pool_state}\n    end\n  end\n  \n  def handle_checkout(:checkout, _from, {host, opts, conn}, pool_state) do\n    if connection_valid?(conn) do\n      {:ok, conn, {host, opts, conn}, pool_state}\n    else\n      Connection.close(conn)\n      # Create new connection\n      case Connection.connect(host, opts) do\n        {:ok, new_conn} -> {:ok, new_conn, {host, opts, new_conn}, pool_state}\n        {:error, reason} -> {:remove, reason, pool_state}\n      end\n    end\n  end\nend\n"})}),"\n",(0,o.jsx)(n.h3,{id:"pool-architecture",children:"Pool Architecture"}),"\n",(0,o.jsx)(n.mermaid,{value:'flowchart TD\n    subgraph Registry["Pool Registry"]\n        r1["host1:22:deploy \u2192 Pool PID"]\n        r2["host2:22:deploy \u2192 Pool PID"]\n        r3["host3:2222:admin \u2192 Pool PID"]\n    end\n\n    subgraph Pool["NimblePool per Host"]\n        c1["Conn 1<br/>idle"]\n        c2["Conn 2<br/>in_use"]\n        c3["Conn 3<br/>idle"]\n        c4["Conn 4<br/>idle"]\n        c5["..."]\n    end\n\n    Registry --\x3e Pool'}),"\n",(0,o.jsx)(n.h3,{id:"authentication-resolution",children:"Authentication Resolution"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"Nexus.SSH.Auth"})," resolves authentication in priority order:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-elixir",children:'def resolve(hostname, opts) do\n  cond do\n    # 1. Explicit identity file\n    opts[:identity] != nil ->\n      resolve_identity(opts[:identity])\n    \n    # 2. Explicit password\n    opts[:password] != nil ->\n      {:ok, {:password, opts[:password]}}\n    \n    # 3. SSH agent (if available)\n    agent_available?() ->\n      {:ok, :agent}\n    \n    # 4. Default key files\n    true ->\n      resolve_default_key(hostname)\n  end\nend\n\ndef agent_available? do\n  case System.get_env("SSH_AUTH_SOCK") do\n    nil -> false\n    "" -> false\n    sock_path -> File.exists?(sock_path)\n  end\nend\n\n@default_key_names ["id_ed25519", "id_ecdsa", "id_rsa", "id_dsa"]\n\ndefp resolve_default_key(_hostname) do\n  ssh_dir = Path.expand("~/.ssh")\n  \n  @default_key_names\n  |> Enum.map(&Path.join(ssh_dir, &1))\n  |> Enum.find(&key_exists?/1)\n  |> case do\n    nil -> {:ok, :none}\n    path -> {:ok, {:identity, path}}\n  end\nend\n'})}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"local-execution",children:"Local Execution"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"Nexus.Executor.Local"})," handles local command execution:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-elixir",children:'def run(command, opts) do\n  timeout = Keyword.get(opts, :timeout, 60_000)\n  shell_opts = build_shell_opts(opts)\n  \n  task = Task.async(fn ->\n    {output, exit_code} = System.shell(command, shell_opts)\n    {:ok, output, exit_code}\n  end)\n  \n  case Task.yield(task, timeout) || Task.shutdown(task, :brutal_kill) do\n    {:ok, result} -> result\n    nil -> {:error, :timeout}\n  end\nend\n\ndef run_streaming(command, opts, callback) do\n  port = Port.open({:spawn, shell_command}, port_opts)\n  stream_loop(port, callback)\nend\n\ndefp stream_loop(port, callback) do\n  receive do\n    {^port, {:data, {:eol, line}}} ->\n      callback.({:stdout, line <> "\\n"})\n      stream_loop(port, callback)\n    \n    {^port, {:exit_status, code}} ->\n      callback.({:exit, code})\n      {:ok, code}\n  end\nend\n'})}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"telemetry",children:"Telemetry"}),"\n",(0,o.jsx)(n.p,{children:"Nexus emits telemetry events for observability:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-elixir",children:'# Event: [:nexus, :task, :start]\n# Measurements: %{system_time: ...}\n# Metadata: %{task: :deploy, on: :webservers}\n\n# Event: [:nexus, :task, :stop]\n# Measurements: %{duration: ..., system_time: ...}\n# Metadata: %{task: :deploy, status: :ok, hosts_succeeded: 3, hosts_failed: 0}\n\n# Event: [:nexus, :command, :start]\n# Measurements: %{system_time: ...}\n# Metadata: %{command: "echo hello", host: :web1}\n\n# Event: [:nexus, :command, :stop]\n# Measurements: %{duration: ...}\n# Metadata: %{command: "echo hello", host: :web1, exit_code: 0}\n\n# Event: [:nexus, :ssh, :connect]\n# Measurements: %{duration: ...}\n# Metadata: %{host: "192.168.1.10", port: 22, user: "deploy"}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"attaching-handlers",children:"Attaching Handlers"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-elixir",children:':telemetry.attach_many(\n  "nexus-logger",\n  [\n    [:nexus, :task, :start],\n    [:nexus, :task, :stop],\n    [:nexus, :command, :start],\n    [:nexus, :command, :stop]\n  ],\n  &handle_event/4,\n  nil\n)\n\ndef handle_event([:nexus, :task, :stop], measurements, metadata, _config) do\n  Logger.info("Task #{metadata.task} completed in #{measurements.duration}ms")\nend\n'})}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,o.jsx)(n.h3,{id:"error-types",children:"Error Types"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-elixir",children:'# Configuration errors\n{:error, "syntax error: ..."}\n{:error, [{:task_deps, "task :deploy depends on unknown task :build"}]}\n\n# Connection errors\n{:error, {:connection_timeout, "192.168.1.10"}}\n{:error, {:connection_refused, "192.168.1.10"}}\n{:error, {:auth_failed, "192.168.1.10"}}\n\n# Execution errors\n{:error, {:command_timeout, "long_running_command"}}\n{:error, {:exec_failed, "command", :reason}}\n\n# DAG errors\n{:error, {:cycle, [:a, :b, :c, :a]}}\n{:error, {:unknown_tasks, [:missing1, :missing2]}}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"error-propagation",children:"Error Propagation"}),"\n",(0,o.jsx)(n.mermaid,{value:'flowchart TD\n    A["Command fails"] --\x3e B["TaskRunner records failure"]\n    B --\x3e C{"Retries left?"}\n    C --\x3e|Yes| D["Retry with backoff"]\n    D --\x3e A\n    C --\x3e|No| E["Mark command as failed"]\n    E --\x3e F{"continue_on_error?"}\n    F --\x3e|No| G["Stop task"]\n    F --\x3e|Yes| H["Continue task"]\n    G --\x3e I["Pipeline receives failure"]\n    H --\x3e I\n    I --\x3e J{"continue_on_error?"}\n    J --\x3e|No| K["Stop pipeline"]\n    J --\x3e|Yes| L["Continue pipeline"]\n    K --\x3e M["CLI exits with code 1"]\n    L --\x3e N["CLI reports partial failure"]'}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,o.jsx)(n.h3,{id:"benchmarks",children:"Benchmarks"}),"\n",(0,o.jsx)(n.p,{children:"From our test suite:"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Operation"}),(0,o.jsx)(n.th,{children:"Time"}),(0,o.jsx)(n.th,{children:"Notes"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"SSH connection"}),(0,o.jsx)(n.td,{children:"~100ms"}),(0,o.jsx)(n.td,{children:"Includes TCP + auth"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Command execution overhead"}),(0,o.jsx)(n.td,{children:"~1.5ms"}),(0,o.jsx)(n.td,{children:"After connection established"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"DAG resolution (100 tasks)"}),(0,o.jsx)(n.td,{children:"<100ms"}),(0,o.jsx)(n.td,{children:"Using libgraph"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"DAG resolution (1000 tasks)"}),(0,o.jsx)(n.td,{children:"<2s"}),(0,o.jsx)(n.td,{children:"Using libgraph"})]})]})]}),"\n",(0,o.jsx)(n.h3,{id:"connection-pooling-impact",children:"Connection Pooling Impact"}),"\n",(0,o.jsx)(n.p,{children:"Without pooling:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"10 commands \xd7 5 hosts = 50 connections\nConnection time: 50 \xd7 100ms = 5000ms overhead\n"})}),"\n",(0,o.jsx)(n.p,{children:"With pooling:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"10 commands \xd7 5 hosts = 5 connections (reused)\nConnection time: 5 \xd7 100ms = 500ms overhead\n"})}),"\n",(0,o.jsx)(n.h3,{id:"memory-usage",children:"Memory Usage"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Base memory: ~50MB (Erlang VM + Nexus)"}),"\n",(0,o.jsx)(n.li,{children:"Per SSH connection: ~2-5MB"}),"\n",(0,o.jsx)(n.li,{children:"100 concurrent connections: ~300-500MB total"}),"\n"]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"extension-points",children:"Extension Points"}),"\n",(0,o.jsx)(n.h3,{id:"custom-authentication",children:"Custom Authentication"}),"\n",(0,o.jsxs)(n.p,{children:["Implement the ",(0,o.jsx)(n.code,{children:"Nexus.SSH.Behaviour"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-elixir",children:"defmodule MyApp.CustomSSH do\n  @behaviour Nexus.SSH.Behaviour\n  \n  @impl true\n  def connect(host, opts) do\n    # Custom connection logic\n  end\n  \n  @impl true\n  def exec(conn, command, opts) do\n    # Custom execution logic\n  end\n  \n  @impl true\n  def close(conn) do\n    # Custom cleanup\n  end\nend\n"})}),"\n",(0,o.jsx)(n.h3,{id:"custom-output-handlers",children:"Custom Output Handlers"}),"\n",(0,o.jsx)(n.p,{children:"Use telemetry to capture and format output:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-elixir",children:'defmodule MyApp.OutputHandler do\n  def setup do\n    :telemetry.attach("custom-output", [:nexus, :command, :stop], &handle/4, nil)\n  end\n  \n  def handle(_, measurements, metadata, _) do\n    # Send to logging service, Slack, etc.\n    MyApp.Slack.notify("Command #{metadata.command} completed in #{measurements.duration}ms")\n  end\nend\n'})}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/nexus/getting-started",children:"Getting Started"})," - Usage guide"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/nexus/configuration",children:"Configuration Reference"})," - DSL documentation"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/nexus/ssh",children:"SSH Configuration"})," - SSH details"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/nexus/troubleshooting",children:"Troubleshooting"})," - Common issues"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}}}]);