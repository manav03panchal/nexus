# Nexus v0.2.5 - Developer Experience & Reliability

## Analysis: What's Missing After v0.2?

### User Pain Points

| Pain Point | Impact | Example |
|------------|--------|---------|
| Single file limitation | High | 500-line nexus.exs becomes unwieldy |
| No conditionals | High | Can't handle Debian vs RHEL differences |
| No task filtering | Medium | Must name specific tasks, no grouping |
| No diff preview | Medium | Can't see what templates would change |
| No host introspection | Medium | Don't know target OS before running |
| No notifications | Medium | Must watch terminal for deploy status |
| Artifacts not implemented | Medium | Can't pass build outputs between tasks |

### v0.2 PRD Items Not Delivered

From the original PRD, these v0.2 features weren't implemented:
- **Artifacts** - File passing between tasks
- **Canary deployment** - Progressive rollout strategy
- **Blue-green deployment** - Zero-downtime switching

### Foundation Needed for v0.3

v0.3 (Distributed & Cloud) will need:
- **Modular configs** → Includes/Imports
- **Heterogeneous cluster support** → Conditionals + Facts
- **Task sharding** → Artifacts
- **Cost awareness** → Check mode with diffs

---

## v0.2.5 Theme: "Developer Experience & Reliability"

Make Nexus more pleasant for daily use while laying groundwork for v0.3.

---

## Feature Breakdown

### Phase 1: Modular Configuration

#### 1.1 Includes/Imports

**Problem:** Single nexus.exs becomes unwieldy for larger projects.

**Solution:**
```elixir
# nexus.exs
import_config "config/hosts.exs"
import_config "config/secrets.exs"
import_tasks "tasks/*.exs"
import_handlers "handlers/*.exs"

task :deploy, deps: [:build] do
  # ...
end
```

**Implementation:**
- New DSL macros: `import_config/1`, `import_tasks/1`, `import_handlers/1`
- Glob pattern support for wildcards
- Circular import detection
- Clear error messages for missing files

**Files:**
- `lib/nexus/dsl/importer.ex` - Import resolution
- Modify `lib/nexus/dsl/parser.ex` - Add import macros

---

#### 1.2 Tags

**Problem:** No way to group and filter tasks.

**Solution:**
```elixir
task :build, tags: [:ci, :dev] do
  run "npm run build"
end

task :test, tags: [:ci, :dev] do
  run "npm test"
end

task :deploy, tags: [:prod] do
  run "deploy.sh"
end
```

```bash
# Run only CI tasks
nexus run --tags ci

# Run multiple tags (OR)
nexus run --tags ci,dev

# Exclude tags
nexus run --skip-tags prod

# Combine with task names
nexus run deploy --tags prod
```

**Implementation:**
- Add `tags` option to task definition
- Add `--tags` and `--skip-tags` CLI options
- Filter tasks before DAG resolution

**Files:**
- Modify `lib/nexus/types.ex` - Add tags to Task struct
- Modify `lib/nexus/dsl/parser.ex` - Parse tags option
- Modify `lib/nexus/cli/run.ex` - Add tag filtering

---

### Phase 2: Conditional Execution

#### 2.1 Facts Gathering

**Problem:** Can't introspect hosts before running commands.

**Solution:**
```elixir
task :install, on: :web do
  # Facts are gathered automatically on first access
  run "apt install nginx", when: facts(:os_family) == :debian
  run "yum install nginx", when: facts(:os_family) == :rhel
  
  # Access facts in commands
  run "echo 'CPUs: #{facts(:cpu_count)}, Memory: #{facts(:memory_mb)}MB'"
end
```

**Built-in Facts:**

| Fact | Type | Example | How Gathered |
|------|------|---------|--------------|
| `os` | atom | `:linux`, `:darwin`, `:windows` | `uname -s` |
| `os_family` | atom | `:debian`, `:rhel`, `:arch`, `:darwin` | `/etc/os-release` or `sw_vers` |
| `os_version` | string | `"22.04"` | `/etc/os-release` |
| `hostname` | string | `"web-1"` | `hostname` |
| `fqdn` | string | `"web-1.example.com"` | `hostname -f` |
| `cpu_count` | integer | `8` | `nproc` or `sysctl` |
| `memory_mb` | integer | `16384` | `/proc/meminfo` or `sysctl` |
| `arch` | atom | `:x86_64`, `:aarch64` | `uname -m` |
| `kernel_version` | string | `"5.15.0"` | `uname -r` |
| `user` | string | `"deploy"` | `whoami` |

**Implementation:**
- Facts gathered lazily on first access (cached per host per run)
- Platform-specific gathering commands
- Custom facts via `gather_fact/2`

**Files:**
- `lib/nexus/facts/gatherer.ex` - Fact collection logic
- `lib/nexus/facts/cache.ex` - Per-run fact cache
- `lib/nexus/facts/parsers.ex` - OS-specific parsers
- Modify `lib/nexus/dsl/parser.ex` - Add `facts/1` function

---

#### 2.2 Conditionals (when:)

**Problem:** Can't conditionally run commands or tasks.

**Solution:**
```elixir
# Command-level conditionals
task :configure do
  run "apt update", when: facts(:os_family) == :debian
  run "yum update", when: facts(:os_family) == :rhel
  
  # Multiple conditions
  run "install-dev-tools.sh", when: env("ENV") == "dev" and facts(:os) == :linux
  
  # Negation
  run "production-setup.sh", when: env("ENV") != "dev"
end

# Task-level conditionals
task :windows_only, when: facts(:os) == :windows do
  run "setup.bat"
end

# Upload/template conditionals
task :deploy do
  upload "linux.conf", "/etc/app.conf", when: facts(:os) == :linux
  upload "darwin.conf", "/etc/app.conf", when: facts(:os) == :darwin
end
```

**Implementation:**
- `when:` option on run, upload, download, template
- `when:` option on task definition (skips entire task)
- Conditions evaluated at runtime after facts gathered
- Support: `==`, `!=`, `and`, `or`, `not`, `in`

**Files:**
- `lib/nexus/conditions/evaluator.ex` - Condition evaluation
- Modify all command types to support `when:` option

---

### Phase 3: Safety & Visibility

#### 3.1 Check Mode (--check)

**Problem:** Can't preview changes without executing.

**Solution:**
```bash
nexus run deploy --check
```

```
╔══════════════════════════════════════════════════════════════════╗
║                         CHECK MODE                                ║
║              No changes will be made                              ║
╚══════════════════════════════════════════════════════════════════╝

● :configure [web-1.example.com]

  template: nginx.conf.eex → /etc/nginx/nginx.conf
  
  --- /etc/nginx/nginx.conf (current)
  +++ /etc/nginx/nginx.conf (proposed)
  @@ -12,7 +12,7 @@
       server {
           listen 80;
  -        server_name old.example.com;
  +        server_name new.example.com;
       }

  upload: app.tar.gz → /opt/app/release.tar.gz
    Local:  app.tar.gz (2.3 MB, modified 2025-01-01 10:30)
    Remote: /opt/app/release.tar.gz (2.1 MB, modified 2024-12-15 14:22)
    Action: Would upload (size changed)

  run: systemctl restart app
    Would execute (no preview available for commands)

● :migrate [db.example.com]
  
  run: ./migrate.sh
    Would execute

========================================
Summary: 2 tasks, 3 hosts, 5 changes
Run without --check to apply changes.
```

**Implementation:**
- Templates: Fetch current remote file, compute diff
- Uploads: Compare size/mtime/checksum
- Downloads: Show what would be downloaded
- Commands: Show "would execute"
- Health checks: Show "would wait for"

**Files:**
- `lib/nexus/check/differ.ex` - Diff computation
- `lib/nexus/check/reporter.ex` - Check mode output
- Modify `lib/nexus/executor/task_runner.ex` - Check mode path

---

#### 3.2 Artifacts

**Problem:** Can't pass build outputs between tasks on different hosts.

**Solution:**
```elixir
task :build, on: :build_server do
  run "make"
  artifact "build/output.tar.gz"  # Declares artifact
end

task :deploy, on: :web, deps: [:build] do
  # Artifact automatically available at same path
  run "tar -xzf build/output.tar.gz -C /opt/app"
end

# With explicit destination
task :build do
  artifact "dist/bundle.js", as: "app.js"
end

task :deploy, deps: [:build] do
  # Available as "app.js" 
  upload artifact("app.js"), "/var/www/app.js"
end
```

**Artifact Flow:**
1. Producer task declares `artifact "path"`
2. After task completes, artifact downloaded to coordinator
3. Stored in `~/.nexus/artifacts/<pipeline-id>/`
4. Before consumer task, artifact uploaded to target host
5. Cleanup after pipeline completes (configurable)

**Files:**
- `lib/nexus/types/artifact.ex` - Artifact struct
- `lib/nexus/artifacts/store.ex` - Local artifact storage
- `lib/nexus/artifacts/transfer.ex` - Upload/download logic
- Modify `lib/nexus/dsl/parser.ex` - Add `artifact/2` macro
- Modify `lib/nexus/executor/task_runner.ex` - Artifact handling

---

### Phase 4: Operations

#### 4.1 Notifications

**Problem:** No way to know when deploys complete without watching terminal.

**Solution:**
```elixir
config :nexus do
  # Webhook notification
  notify :webhook,
    url: "https://hooks.slack.com/services/...",
    on: [:success, :failure],
    template: :slack  # or :discord, :teams, :generic

  # Multiple notifications
  notify :webhook,
    url: env("PAGERDUTY_URL"),
    on: [:failure],
    template: :pagerduty
end

# Or per-task notifications
task :deploy, notify: [:slack] do
  run "deploy.sh"
end
```

**Built-in Templates:**
- `:slack` - Slack Block Kit format
- `:discord` - Discord webhook format
- `:teams` - Microsoft Teams format
- `:generic` - Simple JSON payload
- `:pagerduty` - PagerDuty Events API

**Payload:**
```json
{
  "status": "success",
  "pipeline": "deploy",
  "duration_ms": 45000,
  "tasks": {
    "succeeded": ["build", "test", "deploy"],
    "failed": [],
    "skipped": []
  },
  "hosts": {
    "succeeded": ["web-1", "web-2"],
    "failed": []
  },
  "timestamp": "2025-01-01T10:30:00Z",
  "user": "deploy",
  "git_sha": "abc123",
  "git_branch": "main"
}
```

**Files:**
- `lib/nexus/notifications/sender.ex` - HTTP sender
- `lib/nexus/notifications/templates/` - Format templates
- Modify `lib/nexus/executor/pipeline.ex` - Send on complete

---

## New Dependencies

```elixir
# v0.2.5 additions
{:req, "~> 0.5"},  # HTTP client for notifications & artifact S3
```

Note: `req` was already in v0.2 PRD but not added. It's needed for health check HTTP and notifications.

---

## Implementation Phases

### Phase 1: Modular Configuration (Week 1)
- [ ] Implement `import_config/1` macro
- [ ] Implement `import_tasks/1` with glob support
- [ ] Implement `import_handlers/1`
- [ ] Add circular import detection
- [ ] Add `tags` option to task definition
- [ ] Add `--tags` and `--skip-tags` CLI options
- [ ] Write unit tests
- [ ] Write integration tests

### Phase 2: Conditional Execution (Week 2)
- [ ] Implement facts gatherer
- [ ] Add OS-specific fact parsers (Linux, macOS)
- [ ] Implement fact caching per host
- [ ] Add `facts/1` DSL function
- [ ] Implement condition evaluator
- [ ] Add `when:` option to run/upload/download/template
- [ ] Add `when:` option to task definition
- [ ] Write unit tests
- [ ] Write integration tests

### Phase 3: Safety & Visibility (Week 3)
- [ ] Implement check mode differ for templates
- [ ] Implement check mode for uploads (size/mtime comparison)
- [ ] Implement check mode reporter
- [ ] Add `--check` CLI flag
- [ ] Implement artifact declaration
- [ ] Implement artifact store (local)
- [ ] Implement artifact transfer
- [ ] Write unit tests
- [ ] Write integration tests

### Phase 4: Operations (Week 4)
- [ ] Add `req` dependency
- [ ] Implement notification sender
- [ ] Implement Slack template
- [ ] Implement Discord template
- [ ] Implement generic webhook template
- [ ] Add `notify` config option
- [ ] Add per-task `notify` option
- [ ] Write unit tests
- [ ] Write integration tests

### Final
- [ ] Run full test suite
- [ ] Run quality gates (Credo, Dialyzer, Sobelow)
- [ ] Update CHANGELOG.md
- [ ] Update documentation
- [ ] Bump version to 0.2.5
- [ ] Merge to main

---

## Testing Strategy

| Feature | Unit Tests | Integration Tests | Property Tests |
|---------|------------|-------------------|----------------|
| Imports | importer_test | import_workflow_test | - |
| Tags | tag_filter_test | tag_execution_test | - |
| Facts | gatherer_test, parsers_test | facts_ssh_test | - |
| Conditionals | evaluator_test | conditional_exec_test | condition_props |
| Check Mode | differ_test, reporter_test | check_mode_test | - |
| Artifacts | store_test, transfer_test | artifact_flow_test | - |
| Notifications | sender_test, templates_test | - (mock HTTP) | - |

---

## DSL Summary

New DSL additions in v0.2.5:

```elixir
# Imports
import_config "path/to/config.exs"
import_tasks "tasks/*.exs"
import_handlers "handlers/*.exs"

# Tags
task :build, tags: [:ci, :local] do
  run "make"
end

# Facts
facts(:os)           # :linux, :darwin, :windows
facts(:os_family)    # :debian, :rhel, :arch, :darwin
facts(:hostname)     # "web-1"
facts(:cpu_count)    # 8
facts(:memory_mb)    # 16384

# Conditionals
run "command", when: facts(:os) == :linux
run "command", when: env("ENV") == "prod" and facts(:arch) == :x86_64
task :linux_only, when: facts(:os) == :linux do ... end

# Artifacts
artifact "build/output.tar.gz"
artifact "dist/bundle.js", as: "app.js"
upload artifact("app.js"), "/var/www/app.js"

# Notifications (in config block)
notify :webhook, url: "...", on: [:success, :failure], template: :slack
```

CLI additions:
```bash
nexus run --tags ci
nexus run --skip-tags prod
nexus run deploy --check
```

---

## Backward Compatibility

- All v0.2 nexus.exs files work unchanged
- New options have sensible defaults
- `when:` defaults to `true` (always run)
- No migrations required

---

## Success Criteria

1. Can split 500-line nexus.exs into logical modules
2. Can run subset of tasks by tag without naming each
3. Can handle Debian vs RHEL in same task with conditionals
4. Can preview template changes before applying
5. Can pass build artifacts to deploy tasks
6. Get Slack notification when deploy completes
